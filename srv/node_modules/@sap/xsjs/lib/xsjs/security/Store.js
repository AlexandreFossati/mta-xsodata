'use strict';

var assert = require('assert');
var connection = require('../db/common/connection');
var dbStream = require('@sap/hana-client/extension/Stream');
exports.createStore = createStore;

function createStore(dbReqOptions) {
  var openConnections = new Set();

  var storeConstructor = function (secureStoreFile) {
    var hanaOptions = dbReqOptions.sync.getInstanceOptions();
    var client = connection.sync.connect(hanaOptions);
    openConnections.add(client);
    return new Store(client, secureStoreFile);
  };

  storeConstructor._closeAllConnections = function () {
    for (var client of openConnections) {
      client.close(function () { }); // ignoring an error here;
    }
    openConnections.clear();
  };

  return storeConstructor;
}

function Store(client, secureStoreFile) {
  this._client = client;
  this._secureStoreFile = secureStoreFile;
}

Store.prototype.read = function (parameter) {
  checkParameterHasName(parameter, 'read');
  return read.call(this, parameter, false);
};

Store.prototype.readForUser = function (parameter) {
  checkParameterHasName(parameter, 'readForUser');
  return read.call(this, parameter, true);
};

function read(parameter, isForUser) {
  var result = callProc(this._client, 'CALL "SYS"."USER_SECURESTORE_RETRIEVE"(?, ?, ?, ?)', {
    STORE_NAME: this._secureStoreFile,
    FOR_XS_APPLICATIONUSER: isForUser,
    KEY: parameter.name
  });
  return result && result.VALUE ? result.VALUE.toString('utf8') : null;
}

Store.prototype.remove = function (parameter) {
  checkParameterHasName(parameter, 'remove');
  remove.call(this, parameter, false);
};

Store.prototype.removeForUser = function (parameter) {
  checkParameterHasName(parameter, 'removeForUser');
  remove.call(this, parameter, true);
};

function remove(parameter, isForUser) {
  callProc(this._client, 'CALL "SYS"."USER_SECURESTORE_DELETE"(?, ?, ?)', {
    STORE_NAME: this._secureStoreFile,
    FOR_XS_APPLICATIONUSER: isForUser,
    KEY: parameter.name
  });
}

Store.prototype.store = function (parameter) {
  checkWriteParameter(parameter, 'store');
  store.call(this, parameter, false);
};

Store.prototype.storeForUser = function (parameter) {
  checkWriteParameter(parameter, 'storeForUser');
  store.call(this, parameter, true);
};

function store(parameter, isForUser) {
  callProc(this._client, 'CALL "SYS"."USER_SECURESTORE_INSERT"(?, ?, ?, ?)', {
    STORE_NAME: this._secureStoreFile,
    FOR_XS_APPLICATIONUSER: isForUser,
    KEY: parameter.name,
    VALUE: Buffer.from(parameter.value, 'utf8')
  });
}

function checkWriteParameter(parameter, functionName) {
  checkParameterHasName(parameter, functionName);
  assert(typeof parameter.value === 'string', 'Store.' + functionName + ' should be called with object containing property value - string!');
}

function checkParameterHasName(parameter, functionName) {
  assert(parameter && typeof parameter === 'object', 'Store.' + functionName + ' called with invalid parameter');
  assert(parameter.name && typeof parameter.name === 'string', 'Store.' + functionName + ' should be called with object containing property name - non empty string!');
}

function callProc(client, sql, params) {
  try {
    var stmt = dbStream.sync.createProcStatement(client, sql);
    return stmt.sync.exec(params);
  } finally {
    stmt && stmt.sync.drop();
  }
}
